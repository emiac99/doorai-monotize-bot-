# main.py
import os
import sqlite3
import hashlib
import logging
import requests
import csv
import io
from datetime import datetime
from flask import Flask, request, redirect, abort
from telegram import Bot, Update, InlineKeyboardButton, InlineKeyboardMarkup, InputFile
from telegram.ext import Dispatcher, CommandHandler, CallbackQueryHandler
from apscheduler.schedulers.background import BackgroundScheduler
import pytz

# ---------- CONFIG (env) ----------
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
BOT_USERNAME = os.getenv("BOT_USERNAME", "")
DOMAIN = os.getenv("DOMAIN")   # e.g. https://your-app.up.railway.app
ADMIN_IDS = [int(x) for x in os.getenv("ADMIN_IDS", "").split(",") if x.strip().isdigit()]
SHRINKME_LINK = os.getenv("SHRINKME_LINK", "")
REFERRAL_QUALIFY_CLICKS = int(os.getenv("REFERRAL_QUALIFY_CLICKS", "20"))
REQUIRED_CLICKS_PER_DAY = int(os.getenv("REQUIRED_CLICKS_PER_DAY", "20"))
DB_PATH = os.getenv("DB_PATH", "bot.db")

if not TELEGRAM_TOKEN:
    raise RuntimeError("TELEGRAM_TOKEN is required in environment")
if not DOMAIN:
    raise RuntimeError("DOMAIN is required in environment")

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

bot = Bot(token=TELEGRAM_TOKEN)
app = Flask(__name__)
dispatcher = Dispatcher(bot, None, workers=0, use_context=True)

# ---------- DATABASE ----------
def db_conn():
    return sqlite3.connect(DB_PATH, check_same_thread=False)

def init_db():
    conn = db_conn(); c = conn.cursor()
    c.execute("""
    CREATE TABLE IF NOT EXISTS users (
        user_id INTEGER PRIMARY KEY,
        username TEXT,
        created_at TEXT,
        clicks INTEGER DEFAULT 0,         -- today's clicks (reset daily)
        total_clicks INTEGER DEFAULT 0,   -- all-time clicks
        paid_link TEXT,
        qualified_referrals INTEGER DEFAULT 0
    )""")
    c.execute("""
    CREATE TABLE IF NOT EXISTS referrals (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        referrer INTEGER,
        referee INTEGER UNIQUE,
        qualified INTEGER DEFAULT 0,
        created_at TEXT
    )""")
    c.execute("""
    CREATE TABLE IF NOT EXISTS clicks (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER,
        click_date TEXT,
        ip_hash TEXT,
        ua_hash TEXT,
        created_at TEXT
    )""")
    c.execute("CREATE TABLE IF NOT EXISTS settings (k TEXT PRIMARY KEY, v TEXT)")
    conn.commit(); conn.close()

init_db()

# ---------- UTILITIES ----------
LAGOS = pytz.timezone("Africa/Lagos")

def today_str():
    return datetime.now(LAGOS).date().isoformat()

def fingerprint(ip, ua):
    return hashlib.sha256(f"{ip}|{ua}".encode()).hexdigest()

def get_setting(k):
    conn = db_conn(); c = conn.cursor()
    c.execute("SELECT v FROM settings WHERE k=?", (k,))
    r = c.fetchone(); conn.close()
    return r[0] if r else None

def set_setting(k, v):
    conn = db_conn(); c = conn.cursor()
    c.execute("INSERT OR REPLACE INTO settings(k,v) VALUES(?,?)", (k, v))
    conn.commit(); conn.close()

# persist env shrink link if present
if SHRINKME_LINK:
    set_setting("shrinkme", SHRINKME_LINK)

# ---------- USER & REFERRAL HELPERS ----------
def add_user_if_missing(tg_id, username=None):
    conn = db_conn(); c = conn.cursor()
    c.execute("SELECT 1 FROM users WHERE user_id=?", (tg_id,))
    if not c.fetchone():
        c.execute("INSERT INTO users(user_id, username, created_at) VALUES(?,?,?)",
                  (tg_id, username or "", datetime.utcnow().isoformat()))
        conn.commit()
    else:
        if username:
            c.execute("UPDATE users SET username=? WHERE user_id=?", (username, tg_id))
            conn.commit()
    conn.close()

def add_referral_if_present(new_user_id, payload):
    if not payload: return
    try:
        if payload.startswith("ref_"):
            ref = int(payload.split("_",1)[1])
        else:
            ref = int(payload)
    except:
        return
    if ref == new_user_id: return
    conn = db_conn(); c = conn.cursor()
    c.execute("SELECT 1 FROM referrals WHERE referee=?", (new_user_id,))
    if c.fetchone():
        conn.close(); return
    c.execute("INSERT OR REPLACE INTO referrals(referrer, referee, qualified, created_at) VALUES(?,?,0,?)",
              (ref, new_user_id, datetime.utcnow().isoformat()))
    conn.commit(); conn.close()

def count_user_today(tg_id):
    conn = db_conn(); c = conn.cursor()
    c.execute("SELECT clicks FROM users WHERE user_id=?", (tg_id,))
    r = c.fetchone(); conn.close()
    return r[0] if r else 0

def count_user_total(tg_id):
    conn = db_conn(); c = conn.cursor()
    c.execute("SELECT total_clicks FROM users WHERE user_id=?", (tg_id,))
    r = c.fetchone(); conn.close()
    return r[0] if r else 0

# ---------- ANTI-CHEAT ----------
def is_fast_click(tg_id):
    conn = db_conn(); c = conn.cursor()
    c.execute("""SELECT created_at FROM clicks WHERE user_id=? ORDER BY created_at DESC LIMIT 1""", (tg_id,))
    row = c.fetchone(); conn.close()
    if not row: return False
    try:
        last_time = datetime.fromisoformat(row[0])
    except Exception:
        return False
    diff = (datetime.utcnow() - last_time).total_seconds()
    return diff < 4  # block clicks faster than 4 seconds

def looks_like_proxy(ip):
    if not ip: return True
    ip = ip.strip()
    # private ranges or localhost indicate proxied / local testing; treat as suspicious in production
    private_prefixes = ("10.", "192.168.", "127.", "172.")
    return ip.startswith(private_prefixes)

def suspicious_useragent(ua):
    if not ua: return True
    if len(ua) < 15: return True
    ua_low = ua.lower()
    bad_terms = ["python", "curl", "bot", "scraper", "wget", "urllib"]
    return any(x in ua_low for x in bad_terms)

# ---------- RECORD CLICK ----------
def record_click(tg_id, ip_hash, ua_hash):
    # anti-cheat quick check
    if is_fast_click(tg_id):
        return False
    conn = db_conn(); c = conn.cursor()
    # duplicate fingerprint same day
    c.execute("SELECT 1 FROM clicks WHERE user_id=? AND click_date=? AND ip_hash=?", (tg_id, today_str(), ip_hash))
    if c.fetchone():
        conn.close(); return False
    c.execute("INSERT INTO clicks(user_id, click_date, ip_hash, ua_hash, created_at) VALUES(?,?,?,?,?)",
              (tg_id, today_str(), ip_hash, ua_hash, datetime.utcnow().isoformat()))
    c.execute("UPDATE users SET clicks = clicks + 1, total_clicks = total_clicks + 1 WHERE user_id=?", (tg_id,))
    conn.commit()

    # check referral qualification
    c.execute("SELECT referrer, qualified FROM referrals WHERE referee=?", (tg_id,))
    row = c.fetchone()
    if row:
        referrer, qualified = row
        if not qualified:
            c.execute("SELECT total_clicks FROM users WHERE user_id=?", (tg_id,))
            total = c.fetchone()[0]
            if total >= REFERRAL_QUALIFY_CLICKS:
                c.execute("UPDATE referrals SET qualified=1 WHERE referee=?", (tg_id,))
                c.execute("UPDATE users SET qualified_referrals = qualified_referrals + 1 WHERE user_id=?", (referrer,))
    conn.commit(); conn.close()
    return True

# ---------- FLASK REDIRECT ENDPOINT ----------
@app.route("/")
def home():
    return "Bot is running"

@app.route("/r")
def redirect_to_shrinkme():
    user_param = request.args.get("u")
    if not user_param or not user_param.isdigit():
        abort(400, "missing user")
    tg_id = int(user_param)
    add_user_if_missing(tg_id)
    # fingerprinting
    ip = request.headers.get("X-Forwarded-For", request.remote_addr) or "0.0.0.0"
    ua = (request.headers.get("User-Agent") or "")[:500]
    # anti-cheat
    if looks_like_proxy(ip):
        abort(403, "Proxy not allowed")
    if suspicious_useragent(ua):
        abort(403, "Suspicious device detected")
    ip_hash = hashlib.sha256(ip.encode()).hexdigest()
    ua_hash = hashlib.sha256(ua.encode()).hexdigest()
    ok = record_click(tg_id, ip_hash, ua_hash)
    shrink = get_setting("shrinkme")
    if shrink:
        return redirect(shrink, code=302)
    # fallback: redirect to SHRINKME_LINK env if present
    if SHRINKME_LINK:
        return redirect(SHRINKME_LINK, code=302)
    abort(500, "no target link set")

# ---------- TELEGRAM HANDLERS ----------
def make_menu_keyboard(is_admin=False):
    kb = [
        [InlineKeyboardButton("üîó Get Link", callback_data="getlink")],
        [InlineKeyboardButton("üìä My Stats", callback_data="stats"),
         InlineKeyboardButton("üßæ My Referrals", callback_data="myreferrals")],
        [InlineKeyboardButton("üèÅ Progress (today)", callback_data="progress")]
    ]
    if is_admin:
        kb.append([InlineKeyboardButton("‚öôÔ∏è Admin Panel", callback_data="admin_panel")])
    return InlineKeyboardMarkup(kb)

def start(update: Update, context):
    user = update.effective_user
    payload = context.args[0] if context.args else None
    add_user_if_missing(user.id, user.username)
    add_referral_if_present(user.id, payload)
    kb = make_menu_keyboard(is_admin=(user.id in ADMIN_IDS))
    update.message.reply_text("Welcome! Use the buttons below.", reply_markup=kb)

def getlink_cmd(update: Update, context):
    user = update.effective_user
    add_user_if_missing(user.id, user.username)
    conn = db_conn(); c = conn.cursor()
    c.execute("SELECT paid_link FROM users WHERE user_id=?", (user.id,))
    r = c.fetchone()
    paid = r[0] if r else None
    if not paid:
        # create redirect link to our /r so clicks recorded here route to the final shrink link
        redir = f"{DOMAIN.rstrip('/')}/r?u={user.id}"
        c.execute("UPDATE users SET paid_link=? WHERE user_id=?", (redir, user.id))
        conn.commit()
        paid = redir
    conn.close()
    kb = InlineKeyboardMarkup([[InlineKeyboardButton("Open Link", url=paid)]])
    update.message.reply_text("üîó Tap to open your monetized link (each real open counts):", reply_markup=kb)

def progress(update: Update, context):
    user = update.effective_user
    add_user_if_missing(user.id, user.username)
    today = count_user_today(user.id)
    total = count_user_total(user.id)
    remaining = max(0, REQUIRED_CLICKS_PER_DAY - today)
    update.message.reply_text(f"Today's clicks: {today}/{REQUIRED_CLICKS_PER_DAY}\nTotal clicks (all time): {total}\n{remaining} to go today.")

def getreferral_cmd(update: Update, context):
    user = update.effective_user
    add_user_if_missing(user.id, user.username)
    if BOT_USERNAME:
        link = f"https://t.me/{BOT_USERNAME}?start=ref_{user.id}"
    else:
        link = f"https://t.me/?start=ref_{user.id}"
    update.message.reply_text(f"Share this referral link (referral counts when they reach {REFERRAL_QUALIFY_CLICKS} total clicks):\n{link}")

def myreferrals(update: Update, context):
    user = update.effective_user
    conn = db_conn(); c = conn.cursor()
    c.execute("SELECT referee, qualified, created_at FROM referrals WHERE referrer=? ORDER BY created_at DESC", (user.id,))
    rows = c.fetchall(); conn.close()
    if not rows:
        update.message.reply_text("You have no referrals yet.")
        return
    lines = [f"{r[0]} ‚Äî {'Qualified' if r[1] else 'Pending'} ‚Äî {r[2][:19]}" for r in rows]
    update.message.reply_text("Your referrals:\n" + "\n".join(lines))

def myreferral_stats(update: Update, context):
    user = update.effective_user
    conn = db_conn(); c = conn.cursor()
    c.execute("SELECT COUNT(*), SUM(qualified) FROM referrals WHERE referrer=?", (user.id,))
    r = c.fetchone(); conn.close()
    total = r[0] or 0; qualified = r[1] or 0
    update.message.reply_text(f"Total invited: {total}\nQualified: {qualified}\nPending: {total - qualified}")

# ---------- ADMIN HELPERS ----------
def is_admin(uid): return uid in ADMIN_IDS

def setshrinkme(update: Update, context):
    user = update.effective_user
    if not is_admin(user.id): return update.message.reply_text("Only admin.")
    if not context.args: return update.message.reply_text("Usage: /setshrinkme <shrinkme_url>")
    url = context.args[0].strip()
    set_setting("shrinkme", url)
    update.message.reply_text("ShrinkMe link saved.")

def qualified_today_cmd(update: Update, context):
    user = update.effective_user
    if not is_admin(user.id): return update.message.reply_text("Only admin.")
    conn = db_conn(); c = conn.cursor()
    c.execute("SELECT user_id, COUNT(*) as clicks FROM clicks WHERE click_date=? GROUP BY user_id HAVING clicks>=?",
              (today_str(), REQUIRED_CLICKS_PER_DAY))
    rows = c.fetchall(); conn.close()
    if not rows: return update.message.reply_text("No qualified users today.")
    lines = [f"{i+1}. {r[0]} ‚Äî {r[1]} clicks" for i,r in enumerate(rows)]
    update.message.reply_text("Qualified today:\n" + "\n".join(lines))

def referral_leaderboard(update: Update, context):
    user = update.effective_user
    if not is_admin(user.id): return update.message.reply_text("Only admin.")
    conn = db_conn(); c = conn.cursor()
    c.execute("SELECT user_id, qualified_referrals FROM users ORDER BY qualified_referrals DESC, total_clicks DESC LIMIT 25")
    rows = c.fetchall()
    if not rows: conn.close(); return update.message.reply_text("No referral data available.")
    leaderboard = []
    for i, (uid, qref) in enumerate(rows, start=1):
        c.execute("SELECT username FROM users WHERE user_id=?", (uid,))
        uname = c.fetchone()
        uname = uname[0] if uname and uname[0] else "NoUsername"
        leaderboard.append(f"{i}. @{uname} ({uid}) ‚Äî {qref} qualified referrals")
    conn.close()
    update.message.reply_text("üèÜ Referral Leaderboard:\n\n" + "\n".join(leaderboard))

def admin_ref_details(update: Update, context):
    user = update.effective_user
    if not is_admin(user.id): return update.message.reply_text("Only admin.")
    conn = db_conn(); c = conn.cursor()
    c.execute("SELECT referrer, referee, qualified, created_at FROM referrals ORDER BY created_at DESC LIMIT 200")
    rows = c.fetchall(); conn.close()
    text = "Referrals (latest):\n" + "\n".join([f"{r[0]} -> {r[1]} ‚Äî {'Q' if r[2] else 'P'} ‚Äî {r[3][:16]}" for r in rows])
    update.message.reply_text(text)

# ---------- CSV EXPORT (admin) ----------
def export_qualified_csv(update: Update, context):
    user = update.effective_user
    if not is_admin(user.id): return update.message.reply_text("Only admin.")

    today = today_str()
    conn = db_conn(); c = conn.cursor()
    c.execute("SELECT user_id, COUNT(*) FROM clicks WHERE click_date=? GROUP BY user_id HAVING COUNT(*)>=?", (today, REQUIRED_CLICKS_PER_DAY))
    rows = c.fetchall()
    if not rows:
        conn.close()
        return update.message.reply_text("No qualified users today.")

    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow(["User ID", "Username", "Clicks Today"])
    for r in rows:
        uid, clicks = r
        c.execute("SELECT username FROM users WHERE user_id=?", (uid,))
        uname = c.fetchone()
        uname = uname[0] if uname and uname[0] else ""
        writer.writerow([uid, uname, clicks])
    conn.close()
    output.seek(0)
    bio = io.BytesIO(output.getvalue().encode())
    bio.name = f"qualified_{today}.csv"
    update.message.reply_document(document=InputFile(bio, filename=bio.name))

# ---------- CALLBACK HANDLER (buttons) ----------
def callback_handler(update: Update, context):
    q = update.callback_query
    q.answer()
    uid = q.from_user.id
    data = q.data
    if data == "getlink":
        getlink_cmd(update, context)
    elif data == "stats":
        clicks = count_user_today(uid); total = count_user_total(uid)
        q.edit_message_text(f"üìä Stats:\nToday's clicks: {clicks}\nTotal clicks: {total}\nQualified referrals: (see /myreferral_stats)")
    elif data == "myreferrals":
        myreferrals(update, context)
    elif data == "progress":
        conn = db_conn(); c = conn.cursor()
        c.execute("SELECT COUNT(*) FROM clicks WHERE user_id=? AND click_date=?", (uid, today_str()))
        today_count = c.fetchone()[0]; conn.close()
        remaining = max(0, REQUIRED_CLICKS_PER_DAY - today_count)
        q.edit_message_text(f"Today's clicks: {today_count}/{REQUIRED_CLICKS_PER_DAY}. {remaining} to go today.")
    elif data == "admin_panel":
        if not is_admin(uid): q.edit_message_text("Only admin."); return
        kb = [
            [InlineKeyboardButton("üìã All Users", callback_data="admin_all_users")],
            [InlineKeyboardButton("üèÜ Qualified Today", callback_data="admin_qualified_today")],
            [InlineKeyboardButton("üßæ Referral Details", callback_data="admin_ref_details")],
            [InlineKeyboardButton("üì• Export CSV", callback_data="admin_export_csv")]
        ]
        q.edit_message_text("Admin Panel:", reply_markup=InlineKeyboardMarkup(kb))
    elif data == "admin_all_users":
        if not is_admin(uid): q.edit_message_text("Only admin."); return
        conn = db_conn(); c = conn.cursor()
        c.execute("SELECT user_id, clicks, total_clicks, qualified_referrals FROM users ORDER BY created_at DESC LIMIT 200")
        rows = c.fetchall(); conn.close()
        text = "All users (latest 200):\n" + "\n".join([f"{r[0]} ‚Äî clicks_today:{r[1]} total:{r[2]} qref:{r[3]}" for r in rows])
        q.edit_message_text(text)
    elif data == "admin_qualified_today":
        if not is_admin(uid): q.edit_message_text("Only admin."); return
        conn = db_conn(); c = conn.cursor()
        c.execute("SELECT user_id, COUNT(*) as clicks FROM clicks WHERE click_date=? GROUP BY user_id HAVING clicks>=?", (today_str(), REQUIRED_CLICKS_PER_DAY))
        rows = c.fetchall(); conn.close()
        if not rows: q.edit_message_text("No qualified users today."); return
        text = "Qualified today:\n" + "\n".join([f"{r[0]} ‚Äî {r[1]} clicks" for r in rows])
        q.edit_message_text(text)
    elif data == "admin_ref_details":
        if not is_admin(uid): q.edit_message_text("Only admin."); return
        admin_ref_details(update, context)
    elif data == "admin_export_csv":
        # call the command-like function
        export_qualified_csv(update, context)

# ---------- REGISTER HANDLERS ----------
dispatcher.add_handler(CommandHandler("start", start, pass_args=True))
dispatcher.add_handler(CommandHandler("getlink", getlink_cmd))
dispatcher.add_handler(CommandHandler("progress", progress))
dispatcher.add_handler(CommandHandler("getreferral", getreferral_cmd))
dispatcher.add_handler(CommandHandler("myreferrals", myreferrals))
dispatcher.add_handler(CommandHandler("myreferral_stats", myreferral_stats))
dispatcher.add_handler(CommandHandler("setshrinkme", setshrinkme, pass_args=True))
dispatcher.add_handler(CommandHandler("qualified_today", qualified_today_cmd))
dispatcher.add_handler(CommandHandler("referral_leaderboard", referral_leaderboard))
dispatcher.add_handler(CommandHandler("admin_ref_details", admin_ref_details))
dispatcher.add_handler(CommandHandler("exportcsv", export_qualified_csv))
# admin reset endpoint
def reset_daily_command(update: Update, context):
    user = update.effective_user
    if not is_admin(user.id):
        return update.message.reply_text("Only admin.")
    daily_report_and_reset()
    update.message.reply_text("Manual daily reset and report executed.")
dispatcher.add_handler(CommandHandler("reset_daily", reset_daily_command))

dispatcher.add_handler(CallbackQueryHandler(callback_handler))

# ---------- DAILY REPORT & RESET (Auto + manual) ----------
def daily_report_and_reset():
    tz = LAGOS
    logger.info("Running daily report job (Lagos time)")
    today = datetime.now(tz).date().isoformat()
    conn = db_conn(); c = conn.cursor()
    c.execute("SELECT user_id, COUNT(*) FROM clicks WHERE click_date=? GROUP BY user_id HAVING COUNT(*)>=?", (today, REQUIRED_CLICKS_PER_DAY))
    qualified = c.fetchall()
    # build message
    if not ADMIN_IDS:
        logger.info("No ADMIN_IDS configured; skipping daily report send")
    else:
        if not qualified:
            text = f"üéØ Daily qualified users ({today}
